var searchIndex = JSON.parse('{\
"cp_template":{"doc":"","i":[[0,"input","cp_template","標準入力の簡易入力関数モジュール",null,null],[5,"input_line_str","cp_template::input","文字列を一行読み込む # Example ```ignore use cp_template::*;",null,[[],["string",3]]],[5,"p","","一つの変数を出力する。 ``` use cp_template::*;",null,[[]]],[5,"input_vector2d","","指定した行数を読み込み、二次元配列に変換する。 # Examples ```ignore use…",null,[[],[["vec",3],["vec",3]]]],[5,"input_vector","","一行読み込み、配列(Vec)に変換する。 # Examples ```ignore use…",null,[[],["vec",3]]],[5,"input_vector_row","","指定された行数を読み込む",null,[[],["vec",3]]],[8,"ToCharVec","","StringをVecに変換するトレイト",null,null],[10,"to_charvec","","",0,[[],["vec",3]]],[0,"modint","cp_template","任意の素数を法とする変数",null,null],[3,"Modint","cp_template::modint","",null,null],[3,"DPFactorial","","",null,null],[11,"new","","",1,[[],["modint",3]]],[11,"add_uint","","",1,[[]]],[11,"sub_uint","","",1,[[]]],[11,"mul_uint","","",1,[[]]],[11,"div_uint","","",1,[[]]],[11,"inv","","",1,[[]]],[11,"pow","","",1,[[]]],[11,"get_value","","",1,[[]]],[11,"new","","",2,[[],["dpfactorial",3]]],[11,"get_factorial","","",2,[[],["modint",3]]],[11,"get_factorial_inv","","",2,[[],["modint",3]]],[11,"get_combination","","",2,[[],["modint",3]]],[11,"get_permutation","","",2,[[],["modint",3]]],[0,"prime_number","cp_template","素数関係のライブラリ",null,null],[3,"PrimeFactorization","cp_template::prime_number","",null,null],[11,"calc","","素因数を計算するイテレータを返す。",3,[[],["primefactorization",3]]],[0,"graph","cp_template","グラフ関係のライブラリ",null,null],[5,"bellman_ford","cp_template::graph","最短経路計算(ベルマンフォード法)",null,[[["vec",3],["vec",3]],["vec",3]]],[5,"dijkstra","","最短経路計算(ダイクストラ法)",null,[[["vec",3]],["vec",3]]],[5,"warshall_floyd","","最短経路計算(ワーシャルフロイド法)",null,[[["vec",3]]]],[0,"math","cp_template","数学関係のライブラリ",null,null],[5,"extgcd","cp_template::math","拡張ユーグリッドの互除法",null,[[]]],[0,"vectools","cp_template","配列に関する補助関数ライブラリ",null,null],[5,"upper_bound","cp_template::vectools","C++のupper_boundと同等の実装",null,[[["vec",3]]]],[5,"lower_bound","","C++のlower_boundと同等の実装",null,[[["vec",3]]]],[5,"next_permutation","","次の順列を求める。",null,[[["vec",3]]]],[0,"ordfloat","cp_template","Ordを実装したf64ラッパー",null,null],[3,"OrdFloat","cp_template::ordfloat","",null,null],[12,"0","","",4,null],[0,"union_find","cp_template","素集合データ集合",null,null],[3,"UnionFind","cp_template::union_find","素集合データ構造",null,null],[11,"new","","要素数nの素集合データ構造を構築する。",5,[[],["unionfind",3]]],[11,"find","","親を探索する。",5,[[]]],[11,"same","","親が同じか判定する。",5,[[]]],[11,"union","","結合する。",5,[[]]],[0,"segtree","cp_template","セグメント木",null,null],[3,"SegTreeBasic","cp_template::segtree","汎用のセグメント木",null,null],[11,"new","","セグメント木を構築する。",6,[[],["segtreebasic",3]]],[11,"get","","[l,r)の要素をparent_generatorに基づいて計算する。",6,[[]]],[11,"update","","任意の要素を書き換える。",6,[[]]],[0,"binary_indexed_tree","cp_template","BIT",null,null],[3,"BIT","cp_template::binary_indexed_tree","Binary Indexed Tree",null,null],[11,"new","","BIT木を構築する。",7,[[],["bit",3]]],[11,"add","","任意の要素に値を加算する。",7,[[]]],[11,"get","","[0,index]の区間和を求める。",7,[[]]],[0,"rolling_hash","cp_template","Rolling Hash",null,null],[3,"RollingHash","cp_template::rolling_hash","",null,null],[11,"calc","","ローリングハッシュを計算する。",8,[[],["rollinghash",3]]],[11,"get","","[from:to)のローリングハッシュを求める。",8,[[]]],[0,"flow","cp_template","フロー",null,null],[3,"Dinic","cp_template::flow","最大流を計算(Dinicのアルゴリズム)",null,null],[3,"FordFulkerson","","最大流を計算(Ford-Fulkersonのアルゴリズム)",null,null],[11,"new","","要素数nのグラフを構築する。",9,[[],["dinic",3]]],[11,"get_maxflow","","最大フローを求める。",9,[[]]],[11,"add_edge","","辺の追加",9,[[]]],[11,"new","","要素数nのグラフを構築する。",10,[[],["fordfulkerson",3]]],[11,"get_maxflow","","最大フローを求める。",10,[[]]],[11,"add_edge","","辺の追加",10,[[]]],[0,"z_algorithm","cp_template","Z-Algorithm",null,null],[5,"z_algorithm","cp_template::z_algorithm","Z-Algorithm",null,[[],["vec",3]]],[0,"suffix_array","cp_template","Suffix Array",null,null],[3,"SuffixArray","cp_template::suffix_array","SuffixArrayの計算を行う(Manber&Myersのアルゴリズム)",null,null],[11,"calc","","",11,[[],["vec",3]]],[14,"input","cp_template","空白で区切られた複数の値の読み込む。 # Example ```ignore use cp_template::*;",null,null],[11,"from","cp_template::modint","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"to_string","","",1,[[],["string",3]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","cp_template::prime_number","",3,[[]]],[11,"into","","",3,[[]]],[11,"into_iter","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","cp_template::ordfloat","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","cp_template::union_find","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","cp_template::segtree","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","cp_template::binary_indexed_tree","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","cp_template::rolling_hash","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","cp_template::flow","",9,[[]]],[11,"into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","cp_template::suffix_array","",11,[[]]],[11,"into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"next","cp_template::prime_number","",3,[[],["option",4]]],[11,"clone","cp_template::modint","",1,[[],["modint",3]]],[11,"cmp","cp_template::ordfloat","",4,[[],["ordering",4]]],[11,"eq","cp_template::modint","",1,[[["modint",3]]]],[11,"ne","","",1,[[["modint",3]]]],[11,"eq","cp_template::ordfloat","",4,[[["ordfloat",3]]]],[11,"ne","","",4,[[["ordfloat",3]]]],[11,"partial_cmp","","",4,[[],[["ordering",4],["option",4]]]],[11,"deref","","",4,[[]]],[11,"fmt","cp_template::modint","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"from_str","","",1,[[],["result",4]]]],"p":[[8,"ToCharVec"],[3,"Modint"],[3,"DPFactorial"],[3,"PrimeFactorization"],[3,"OrdFloat"],[3,"UnionFind"],[3,"SegTreeBasic"],[3,"BIT"],[3,"RollingHash"],[3,"Dinic"],[3,"FordFulkerson"],[3,"SuffixArray"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);