var N=null,E="",T="t",U="u",searchIndex={};
var R=["cp_template","modint","usize","cp_template::modint","string","result","try_from","try_into","borrow","borrow_mut","cp_template::prime_number","type_id","cp_template::ordfloat","cp_template::union_find","typeid","cp_template::segtree","cp_template::binary_indexed_tree","cp_template::rolling_hash","cp_template::flow","ordfloat","ordering","formatter","ToCharVec","DPFactorial","PrimeFactorization","OrdFloat","UnionFind","SegTreeBasic","RollingHash","FordFulkerson"];

searchIndex["cp_template"]={"doc":E,"i":[[0,"input",R[0],"標準入力の簡易入力関数モジュール",N,N],[5,"input_line_str","cp_template::input","文字列を一行読み込む # Example ```ignore use cp_template::*;",N,[[],[R[4]]]],[5,"p",E,"一つの変数を出力する。 ``` use cp_template::*;",N,[[[T]]]],[5,"input_vector2d",E,"指定した行数を読み込み、二次元配列に変換する。 # Examples ```ignore use…",N,[[[R[2]]],[["vec",["vec"]],["vec"]]]],[5,"input_vector",E,"一行読み込み、配列(Vec)に変換する。 # Examples ```ignore use…",N,[[],["vec"]]],[5,"input_vector_row",E,"指定された行数を読み込む",N,[[[R[2]]],["vec"]]],[8,R[22],E,"StringをVecに変換するトレイト",N,N],[10,"to_charvec",E,E,0,[[["self"]],[["char"],["vec",["char"]]]]],[0,R[1],R[0],"任意の素数を法とする変数",N,N],[3,"Modint",R[3],E,N,N],[3,R[23],E,E,N,N],[11,"new",E,E,1,[[["u64"]],[R[1]]]],[11,"add_uint",E,E,1,[[["self"],["u64"]],["self"]]],[11,"sub_uint",E,E,1,[[["self"],["u64"]],["self"]]],[11,"mul_uint",E,E,1,[[["self"],["u64"]],["self"]]],[11,"div_uint",E,E,1,[[["self"],["u64"]],["self"]]],[11,"inv",E,E,1,[[["self"]],["self"]]],[11,"pow",E,E,1,[[["self"],[R[2]]],["self"]]],[11,"get_value",E,E,1,[[["self"]],["u64"]]],[11,"new",E,E,2,[[],["dpfactorial"]]],[11,"get_factorial",E,E,2,[[["self"],[R[2]]],[R[1]]]],[11,"get_factorial_inv",E,E,2,[[["self"],[R[2]]],[R[1]]]],[11,"get_combination",E,E,2,[[["self"],[R[2]]],[R[1]]]],[11,"get_permutation",E,E,2,[[["self"],[R[2]]],[R[1]]]],[0,"prime_number",R[0],"素数関係のライブラリ",N,N],[3,R[24],R[10],E,N,N],[11,"calc",E,"素因数を計算するイテレータを返す。",3,[[[R[2]]],["primefactorization"]]],[0,"graph",R[0],"グラフ関係のライブラリ",N,N],[5,"bellman_ford","cp_template::graph","最短経路計算(ベルマンフォード法)",N,[[["vec"],["vec"]],[["vec",["bool"]],["bool"]]]],[5,"dijkstra",E,"最短経路計算(ダイクストラ法)",N,[[["vec"],[R[2]]],[["isize"],["vec",["isize"]]]]],[5,"warshall_floyd",E,"最短経路計算(ワーシャルフロイド法)",N,[[["vec"]]]],[0,"math",R[0],"数学関係のライブラリ",N,N],[5,"gcd","cp_template::math","最大公約数を求める。",N,[[[T]],[T]]],[5,"lcm",E,"最小公倍数を求める。",N,[[[T]],[T]]],[5,"extgcd",E,"拡張ユーグリッドの互除法",N,[[[T],[T]],[T]]],[0,"vectools",R[0],"配列に関する補助関数ライブラリ",N,N],[5,"upper_bound","cp_template::vectools","C++のupper_boundと同等の実装",N,[[["vec"],[T]],[R[2]]]],[5,"lower_bound",E,"C++のlower_boundと同等の実装",N,[[["vec"],[T]],[R[2]]]],[5,"next_permutation",E,"次の順列を求める。",N,[[["vec"]],["bool"]]],[0,R[19],R[0],"Ordを実装したf64ラッパー",N,N],[3,R[25],R[12],E,N,N],[12,"0",E,E,4,N],[0,"union_find",R[0],"素集合データ集合",N,N],[3,R[26],R[13],"素集合データ構造",N,N],[11,"new",E,"要素数nの素集合データ構造を構築する。",5,[[[R[2]]],["unionfind"]]],[11,"find",E,"親を探索する。",5,[[["self"],[R[2]]],[R[2]]]],[11,"same",E,"親が同じか判定する。",5,[[["self"],[R[2]]],["bool"]]],[11,"union",E,"結合する。",5,[[["self"],[R[2]]]]],[0,"segtree",R[0],"セグメント木",N,N],[3,R[27],R[15],"汎用のセグメント木",N,N],[11,"new",E,"セグメント木を構築する。",6,[[["f"],[R[2]],[T]],["segtreebasic"]]],[11,"get",E,"[l,r)の要素をparent_generatorに基づいて計算する。",6,[[["self"],[R[2]]],[T]]],[11,"update",E,"任意の要素を書き換える。",6,[[["self"],[R[2]],[T]]]],[0,"binary_indexed_tree",R[0],"BIT",N,N],[3,"BIT",R[16],"Binary Indexed Tree",N,N],[11,"new",E,"BIT木を構築する。",7,[[[R[2]]],["bit"]]],[11,"add",E,"任意の要素に値を加算する。",7,[[["self"],[R[2]],["u64"]]]],[11,"get",E,"[0,index]の区間和を求める。",7,[[["self"],[R[2]]],["u64"]]],[0,"rolling_hash",R[0],"Rolling Hash",N,N],[3,R[28],R[17],E,N,N],[11,"calc",E,"ローリングハッシュを計算する。",8,[[["str"],["u64"]],["rollinghash"]]],[11,"get",E,"[from:to)のローリングハッシュを求める。",8,[[["self"],[R[2]]],["u64"]]],[0,"flow",R[0],"フロー",N,N],[3,R[29],R[18],"最大流を計算(Ford-Fulkersonのアルゴリズム)",N,N],[11,"new",E,"要素数nのグラフを構築する。",9,[[[R[2]]],["fordfulkerson"]]],[11,"get_maxflow",E,"最大フローを求める。",9,[[["self"],[R[2]]],["u64"]]],[11,"add_edge",E,"辺の追加",9,[[["self"],[R[2]],["u64"]]]],[14,"input",R[0],"空白で区切られた複数の値の読み込む。 # Example ```ignore use cp_template::*;",N,N],[11,"into",R[3],E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"to_owned",E,E,1,[[["self"]],[T]]],[11,"clone_into",E,E,1,[[["self"],[T]]]],[11,"to_string",E,E,1,[[["self"]],[R[4]]]],[11,R[6],E,E,1,[[[U]],[R[5]]]],[11,R[7],E,E,1,[[],[R[5]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[5]]]],[11,R[7],E,E,2,[[],[R[5]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"into",R[10],E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into_iter",E,E,3,[[],["i"]]],[11,R[6],E,E,3,[[[U]],[R[5]]]],[11,R[7],E,E,3,[[],[R[5]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"into",R[12],E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[5]]]],[11,R[7],E,E,4,[[],[R[5]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"into",R[13],E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[5]]]],[11,R[7],E,E,5,[[],[R[5]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,"into",R[15],E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[5]]]],[11,R[7],E,E,6,[[],[R[5]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,"into",R[16],E,7,[[],[U]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[5]]]],[11,R[7],E,E,7,[[],[R[5]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,"into",R[17],E,8,[[],[U]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[6],E,E,8,[[[U]],[R[5]]]],[11,R[7],E,E,8,[[],[R[5]]]],[11,R[8],E,E,8,[[["self"]],[T]]],[11,R[9],E,E,8,[[["self"]],[T]]],[11,R[11],E,E,8,[[["self"]],[R[14]]]],[11,"into",R[18],E,9,[[],[U]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[6],E,E,9,[[[U]],[R[5]]]],[11,R[7],E,E,9,[[],[R[5]]]],[11,R[8],E,E,9,[[["self"]],[T]]],[11,R[9],E,E,9,[[["self"]],[T]]],[11,R[11],E,E,9,[[["self"]],[R[14]]]],[11,"next",R[10],E,3,[[["self"]],["option"]]],[11,"clone",R[3],E,1,[[["self"]],[R[1]]]],[11,"cmp",R[12],E,4,[[["self"]],[R[20]]]],[11,"eq",R[3],E,1,[[[R[1]],["self"]],["bool"]]],[11,"ne",E,E,1,[[[R[1]],["self"]],["bool"]]],[11,"eq",R[12],E,4,[[["self"],[R[19]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[19]]],["bool"]]],[11,"partial_cmp",E,E,4,[[["self"]],[["option",[R[20]]],[R[20]]]]],[11,"fmt",R[3],E,1,[[["self"],[R[21]]],[R[5]]]],[11,"fmt",E,E,1,[[["self"],[R[21]]],[R[5]]]],[11,"from_str",E,E,1,[[["str"]],[R[5]]]],[11,"deref",R[12],E,4,[[["self"]],["f64"]]]],"p":[[8,R[22]],[3,"Modint"],[3,R[23]],[3,R[24]],[3,R[25]],[3,R[26]],[3,R[27]],[3,"BIT"],[3,R[28]],[3,R[29]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);